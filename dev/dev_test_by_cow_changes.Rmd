---
title: "dev - changes to regression 'by cow'"
output: html_notebook
---

After running analysis on large data it seems that the first fit of the regression is not always robust against very large negatives or very long durations. So, it would seem more appropriate to flag them as outliers first so that the initial fit can get a more realistic 'scaling factor' which is used as SD.

Further development below shows the case for using more user-defined thresholds, such as max and min allowable rate of intake. It is much easier to set a maximum rate of intake compared to a min, as a very slow intake is theoretically possible, but perhaps unlikely.


Mensching - transformed due to skew

```{r setup}
library(tidyverse, quietly = TRUE)
```



# Import test data for new outlier detection
It seems that on large data we need to use a very high threshold for outlier detection becuase of poorly fitting models

I've extracted an example from Arnulfo's long-term trial where I first noticed this problem
```{r}
bybin_test_df <- readRDS("subset_bybin_for_testing.rds")
bybin_test_df |> glimpse()
```


```{r}
bybin_test_df |> 
  group_by(animal_id, date) |> 
  #filter(between(date, lubridate::ymd('2023-06-01'), lubridate::ymd('2023-06-30'))) |> 
  summarise(daily_intake = sum(corrected_intake_bybin)) |> 
  ggplot(aes(x = date, y = daily_intake, colour = animal_id))+
  geom_point()+
  facet_wrap(vars(animal_id))
```


# Set up test functions for dev
## flag and replace outliers
```{r}
# This version of function has multiple hard-coded tresholds for rates of intake that are plotted.
# A different version is copied at end of notebook for user-supplied threshold
dev_flag_and_replace_outliers <-
  function(df_in,
           col_intake = corrected_intake_bybin,
           col_duration = corrected_feed_duration_seconds,
           col_cow_id = animal_id,
           col_bin_id = bin_id,
           col_start_time = start_time,
           col_date = date,
           sd_thresh = Inf){
    #
    col_y <- rlang::ensym(col_intake)
    col_x <- rlang::ensym(col_duration)

    c_y <- rlang::enquo(col_intake) %>% rlang::as_name()
    c_x <- rlang::enquo(col_duration) %>% rlang::as_name()

    c_cow_id <- rlang::enquo(col_cow_id) %>% rlang::as_name()
    c_bin_id <- rlang::enquo( col_bin_id ) %>% rlang::as_name()
    c_start_time <- rlang::enquo( col_start_time ) %>% rlang::as_name()
    c_date <- rlang::enquo( col_date ) %>% rlang::as_name()

    # drop NA values - rlm() won't work otherwise
    # There shouldn't be NA value, as errors from first step retained their original intake values
    df_in <-
      df_in %>%
      tidyr::drop_na({{ col_intake }},  {{ col_duration }}) |>
      # Calculate rate of intake for downstream
      dplyr::mutate(instant_rate_of_intake_kg_s = {{ col_intake }} / {{ col_duration }},
                    instant_rate_of_intake_kg_min = instant_rate_of_intake_kg_s * 60) 
      
    ############################################# #
    # Check data
    # 1. that only 1 cow of data is entered
    # 2. that more than 3 rows of data are included for regression
    ############################################# #

    n_cows <- df_in %>% dplyr::pull({{ col_cow_id }}) %>% dplyr::n_distinct()
    if(n_cows > 1){
      warning("More than 1 cow detected in df_in. This function requires 1 cow at a time, see f_iterate_cows().")
      return(NULL)
    }

    n_row <- df_in %>% nrow()
    if(n_row < 5){
      warning(paste0(
        "Less than 5 events for current cow. Aborting regression fit and keeping original intakes & durations. Cow number:\n",
        df_in %>% dplyr::pull({{ col_cow_id}}) %>% unique(),
        "\nNumber of rows:\n",
        n_row
        ))

      # copy original values to new columns that would be added below
      # keep only minimum amount of columns to allow data to be merged with 'fitted' df's
      out <- df_in %>%
        dplyr::mutate(
          new_x = {{ col_duration }},
          new_y = {{ col_intake }},
          manual_outlier_classification = 'insufficient_rows_for_regression',
          is_manual_outlier = FALSE
        ) %>%
        dplyr::select( tidyselect::all_of(
          #all_of returns an error if some are missing, but requires char vector, hence the enquo(), as_name() + bang-bang
          c(
            !!c_cow_id,
            !!c_bin_id,
            !!c_start_time,
            !!c_date,
            !!c_x,
            !!c_y,
            'new_x',
            'new_y',
            'instant_rate_of_intake_kg_min',
            'insufficient_rows_for_regression',
            'is_manual_outlier'
          )
        )) %>%
        dplyr::mutate(
          is_outlier = FALSE,
          outlier_pos_neg = 'insufficient_rows_for_regression'
        )

      return(out)
    }


    ############################################# #
    # Manual outliers - based on rate of intake
    # This uses thresholds set by user for what is 
    # realistic for dairy cows to do - not stats.
    ############################################# #

    # Set negative intakes and long durations (> 60 min) as outliers prior to first regression
    # This helps to maintain a more robust linear model, as very negative intakes or very long durations will still
    # skew the rlm().
    # df_in <- df_in %>% 
    #   dplyr::mutate(
    #     initial_outlier_check = {{ col_intake }} < 0 | {{ col_duration }} < 120
    #   )
    
    df_in <- 
      df_in |> 
      # dplyr::mutate(instant_rate_of_intake_kg_s = {{ col_intake }} / {{ col_duration }},
      #        instant_rate_of_intake_kg_min = instant_rate_of_intake_kg_s * 60) |> 
      dplyr::arrange(dplyr::desc(instant_rate_of_intake_kg_s)) |>
      dplyr::filter(instant_rate_of_intake_kg_min >= 0) |> 
      dplyr::mutate(
        manual_outlier_classification = dplyr::case_when(
          # ignore <= 60 seconds and < 300 g (red box on plot)
          {{ col_duration }} <= 60 &  {{ col_intake }} < 0.3 ~ 'Not Outlier',
          
          
          instant_rate_of_intake_kg_min > 1 ~ '>1 kg/min',
          instant_rate_of_intake_kg_min > 2 ~ '>2 kg/min',
          instant_rate_of_intake_kg_min < 0.05 ~ '<0.050 kg/min',
          instant_rate_of_intake_kg_min < 0.075 ~ '<0.075 kg/min',
          instant_rate_of_intake_kg_min < 0.1 ~ '<0.100 kg/min',
           {{ col_duration }} > (60*60) ~ "Long Duration",
          
          .default = 'Not Outlier'
        ),
        is_manual_outlier = manual_outlier_classification != 'Not Outlier'
      )
    
    # split data into 2 dataframes based on initial flag. 
    # Data removed here is re-attached to df after rlm() step
    df_in_rlm <- df_in %>% dplyr::filter(!is_manual_outlier)
    
    df_in_initial_outliers <- df_in %>% dplyr::filter(is_manual_outlier)
    
    ############################################# #
    # Fit robust linear model to detect outliers
    # A treshold for residual SD can still be applied
    # This is more arbitrary and can behave unexpectedly if
    # initial robust linear fit is skewed
    ############################################# #
    
    # # INTERCEPT FIXED THROUGH 0:
    rlm_out  <- MASS::rlm(
      rlang::inject(!!col_y ~ 0+!!col_x),
      data = df_in_rlm,
      psi = MASS::psi.huber,
      method = "M",
      init = 'lts',
      maxit = 5000)
    
    # value from model used as 'sd' for outlier detection
    scale_num <-  rlm_out$s

    resid_df_outliers <-
      broom::augment(rlm_out, newdata = stats::model.frame(rlm_out))  %>%
      dplyr::bind_cols(
        df_in_rlm %>%
          dplyr::select(
            #all_of returns an error if some are missing, but requires char vector, hence the enquo(), as_name() + bang-bang
            tidyselect::all_of(
            c(
              !!c_cow_id,
              !!c_bin_id,
              !!c_start_time,
              !!c_date,
              "manual_outlier_classification",
              "is_manual_outlier",
              "instant_rate_of_intake_kg_min"
            )
          )
          )
      )  %>%
      # Add initial outliers back in:
      dplyr::bind_rows(
        df_in_initial_outliers %>%
          dplyr::select(
            tidyselect::all_of(
            c(
              !!c_y,
              !!c_x,
              !!c_cow_id,
              !!c_bin_id,
              !!c_start_time,
              !!c_date,
              "manual_outlier_classification",
              "is_manual_outlier",
              "instant_rate_of_intake_kg_min"
            )
          )
          )) |>
      dtplyr::lazy_dt() %>%
      dplyr::mutate(
        is_outlier = abs(.data$.resid) >= sd_thresh * scale_num | {{ col_intake }} < 0 | .data$is_manual_outlier == TRUE
        
        ) %>%
      dplyr::as_tibble() # required to collect lazy_dt()


    ##############################################
    # Fit bisector linear model that is symmetrical
    ##############################################

    # This allows for bi-directional prediction of either x or y
    # similar to SMA but easier to implement

    # select only points that were not considered outliers above to fit bisector line to
    # this is only used for calculation, and all data is still returned at end
    df_no_outliers <- resid_df_outliers  %>% dplyr::filter(.data$is_outlier == FALSE)
    

    # These methods are faster than others for getting values required:
    # uses names that are similar to Isobe 1990 paper

    # mean of x and y
    means <- df_no_outliers %>%
      dplyr::select({{ col_x }}, {{ col_y }}) %>%
      base::colMeans(na.rm=TRUE)

    # sum of squares calculations:
    SS <- df_no_outliers  %>%
      dplyr::select({{ col_x }}, {{ col_y }}) %>%
      dplyr::mutate(
        s_xy = ({{ col_x }} - means[[col_x]] ) *({{ col_y }} - means[[col_y]]),
        s_xx = ({{ col_x }} - means[[col_x]])^2,
        s_yy = ({{ col_y }} - means[[col_y]])^2)

    # Total sum of squares
    TSS <- SS %>% base::colSums()

    # Calculate slope and intercept for bisector model from Isobe 1990:
    b_xy <- TSS[['s_xy']] / TSS[['s_xx']] # normal lm
    b_yx <- TSS[['s_yy']] / TSS[['s_xy']] # inverse - used by bis

    # slope:
    b_bis <-  (b_xy + b_yx)^-1*(b_xy * b_yx - 1 + sqrt((1+b_xy^2)*(1+b_yx^2)))

    # Intercept:
    #b0_bis = means[[col_y]] - b_bis * means[[col_x]]
    
    # Force intercept to 0 as this is biologically more relevent and prevents estimating negative intakes
    b0_bis = 0

    ####################################################
    # Fit model for outliers:
    ####################################################
    # functions to predict in either direction
    .f_pred_y <- function(x){
      y = b_bis * x  + b0_bis
      return(y)
    }

    .f_pred_x <- function(y){
      x = (y - b0_bis) / b_bis
      return(x)
    }


    predicted_and_corrected <-
      resid_df_outliers %>%
      dtplyr::lazy_dt() %>%
      dplyr::mutate(
        # calculate predicted values for plotting regression
        predicted_y_bisector = b_bis * {{ col_x }} + b0_bis,
        residual_y_bisector = {{ col_intake }} - .data$predicted_y_bisector,
        
        # classify if outlier should be corrected along x or y axis:
        outlier_pos_neg = dplyr::case_when(.data$is_outlier & {{ col_intake }} < 0 ~ "neg_intake",
                                           .data$is_outlier & {{ col_duration }} < 0  ~ "neg_duration",
                                           .data$is_outlier & .data$residual_y_bisector < 0 ~ "neg",
                                           .data$is_outlier & .data$residual_y_bisector > 0  ~ "pos"),

        # New x and y - with outliers given predicted values:
        new_y = dplyr::case_match(.data$outlier_pos_neg,
                                  'pos' ~ .f_pred_y({{ col_duration }}),
                                  'neg_intake' ~ 0, #set neg intakes to 0
                                  .default =  {{ col_intake }} ),

        new_x = dplyr::case_match(.data$outlier_pos_neg,
                                  'neg' ~ .f_pred_x({{ col_intake }}),
                                  'neg_duration' ~ .f_pred_x({{ col_intake }}),
                                  .default = {{ col_duration }}),
        # store b0 and b_bis in columns to access later for rate of intake
        intercept = b0_bis,
        slope = b_bis,
        
      ) %>%
      dplyr::as_tibble() |>  # required to collect lazy_dt() 
      dplyr::mutate(
        #add final classification of all outliers
        outlier_classification = dplyr::case_when(
          is_manual_outlier == FALSE & is_outlier == TRUE ~ 'Residual > SD threshold',
          is_manual_outlier == TRUE ~ manual_outlier_classification,
          is_outlier == FALSE ~ "Not Outlier",
          .default = NA_character_
        )
      )
    
    
    
    return(list(df = predicted_and_corrected, rlm =  rlm_out, df_no_outliers = df_no_outliers))
  }
```

## Plot
```{r}

dev_plot_by_cow <- function(df,
                            max_intake_rate_kg_min = 1,
                            min_intake_rate_kg_min = 0.05,
                            col_intake = corrected_intake_bybin,
                            col_duration = corrected_feed_duration_seconds,
                            col_cow_id = animal_id,
                            pt_size = 3){

  df_outliers <- df %>%  dplyr::filter(is_outlier)
  
  # for setting coord-cartesian
  max_intake <- df |> pull({{ col_intake }}) |> max()

  p <- df %>%
    # dplyr::mutate(
    #   upper_line = max_intake_rate_kg_min/60 * {{ col_duration }}
    # ) |>
    ggplot(aes(x = {{ col_duration }}, y = {{ col_intake }}, text = paste("cow_id:", {{ col_cow_id }})))+
    # geom_point(aes(shape = .data$is_outlier, colour = .data$outlier_pos_neg), size = pt_size)+
    geom_point(aes(
     
      colour = .data$outlier_pos_neg, 
      fill = .data$outlier_classification,
      text = paste("Rate of Intake kg/min: ", instant_rate_of_intake_kg_min)
      # shape = .data$is_outlier
      ), 
      size = pt_size, 
      shape = 21
      )+
     # scale_shape_manual(values = c(21,24))+
    geom_function(aes(linetype = 'Boundary of max intake rate kg/min'),
                  fun = ~ max_intake_rate_kg_min/60 * .x,
                  colour = 'black',
                  linewidth = 0.8)+
    geom_function(aes(linetype = 'Boundary of min intake rate kg/min'),
                  fun = ~ min_intake_rate_kg_min/60 * .x,
                  colour = 'black',
                  linewidth = 0.8)+
    # geom_function(aes(colour = 'Boundary of max intake rate kg/min'),
    #               fun = ~ max_intake_rate_kg_min/60 * .x,
    #               linetype = 'twodash',
    #               # colour = 'black',
    #               linewidth = 0.7)+
    # geom_function(aes(colour = 'Boundary of min intake rate kg/min'),
    #               fun = ~ min_intake_rate_kg_min/60 * .x,
    #               linetype = 'twodash',
    #               # colour = 'black',
    #               linewidth = 0.7)+
    geom_line(aes(y = .fitted, 
                  linetype = '1) Robust Linear Regression'),
              # colour = 'blue',
              linewidth = 0.8)+
    geom_line(aes(y = .data$predicted_y_bisector, linetype = '2) Bisector Regression'),
              # colour = 'blue',
              linewidth = 0.8)+
    # geom_function(aes(linetype = paste0('Max intake rate kg/min: ', max_intake_rate_kg_min)), 
    #               fun = ~ max_intake_rate_kg_min/60 * .x)+
    # geom_function(aes(linetype = paste0('Min intake rate kg/min: ', min_intake_rate_kg_min)),
    #               fun = ~ min_intake_rate_kg_min/60 * .x)+
    # geom_line(aes(y = upper_line, linetype = "Max"), colour = 'darkred', linewidth = 1)+
    
    # geom_function(aes(linetype = 'Max intake rate kg/min: '),
    #               fun = ~ max_intake_rate_kg_min/60 * .x,
    #               linewidth = 0.8)+
    # geom_function(aes(linetype = 'Min intake rate kg/min: '),
    #               fun = ~ min_intake_rate_kg_min/60 * .x,
    #               linewidth = 0.8)+
    # 
    
    ggplot2::scale_linetype_manual(
      values = c('1) Robust Linear Regression' = 'dashed',
                 '2) Bisector Regression' = 'solid',
                 'Boundary of max intake rate kg/min' = 'dotted',
                 'Boundary of min intake rate kg/min' = 'twodash'
                 )) +

    # add points for outliers only:
    # geom_point(aes(x = .data$new_x, y = .data$new_y, colour = .data$outlier_pos_neg), size = pt_size,
    #            data = df_outliers)+
     geom_point(aes(
       x = .data$new_x, y = .data$new_y,
      colour = .data$outlier_pos_neg, 
      fill = .data$outlier_classification,
      # shape = .data$is_outlier
      ), 
      size = pt_size, shape = 21,
      data = df_outliers
      )+

    # Draw line between points that changed (inherits x and y from ggplot call):
    geom_segment(aes(xend = .data$new_x, yend = .data$new_y, colour = .data$outlier_pos_neg),
                 alpha = 0.75,
                 linewidth = 0.8,
                 data = df_outliers,
                 arrow = grid::arrow(angle = 20, length = ggplot2::unit(0.4, 'cm')),
                 linejoin = 'mitre')+
    

    
    geom_rect(aes(xmin = 0, xmax = 60, ymin = 0, ymax = 0.2), fill = NA, colour = 'red')+
    
    # rename labels and format:
    labs(title = df %>% dplyr::pull({{ col_cow_id }}) %>% unique(),
         linetype = "Fitted Line Type")+
    # NA values are from outlier_pos_neg (if NA it means it wasn't an outlier)
    ggplot2::scale_colour_viridis_d("Outlier type", option = 'D',
                                    end = 0.8, na.value = "grey60")+
        ggplot2::scale_fill_viridis_d("Outlier Classification", option = 'H',
                                    end = 0.8, na.value = "grey60")+
    ggplot2::theme_classic(base_size = 18)+
    ggplot2::theme(axis.text = ggplot2::element_text(colour = 'black'))+
    coord_cartesian(ylim = c(NA,max_intake),
                    # xlim = c(0,500)
                    )+
    NULL
  
  return(p)

}
```



# Execute test functions


```{r}
onecowdf <- bybin_test_df |>  filter(animal_id == 4897) 

# onecowrlm <- onecowdf |>  dev_flag_and_replace_outliers()
onecowrlm <- onecowdf |>  dev_flag_and_replace_outliers(sd_thresh = Inf)
rlm_out <- onecowrlm$rlm
broom::augment(rlm_out, newdata = stats::model.frame(rlm_out))  |> 
   ggplot(aes(x = corrected_feed_duration_seconds))+
   geom_point(aes( y = corrected_intake_bybin))+
   geom_line(aes(y = .fitted))
 
```



```{r}


p_newmethod <- 
  onecowrlm$df |> 
   ggplot(aes(x = corrected_feed_duration_seconds))+
   geom_point(aes( y = corrected_intake_bybin, colour = outlier_classification, shape = is_outlier, text = paste("ROI kg/min: ", instant_rate_of_intake_kg_min)))+
  scale_colour_viridis_d(na.value = 'grey20')+
  scale_shape_discrete(na.value = 1)+
   geom_line(aes(y = .fitted), colour = 'red')+
  geom_line(aes(y = predicted_y_bisector), colour = 'blue')

# broom::augment(rlm_out, newdata = stats::model.frame(rlm_out), se_fit = TRUE) 
p_newmethod
plotly::ggplotly(p_newmethod)
```

## View histogram of intake
This shows the right skew which may make it harder for linear models to fit
```{r}
p_hist_intake <- 
  onecowrlm$df |> 
  ggplot()+
  geom_histogram(aes(x = corrected_intake_bybin), binwidth = 0.1)

plotly::ggplotly(p_hist_intake)
```

```{r}
  onecowrlm$df |> 
  ggplot()+
  geom_histogram(aes(x = corrected_intake_bybin), binwidth = 0.1)+
  scale_x_continuous(trans = 'sqrt')
```


See how much daily intakes change when removing 0.2 kg or less, or check how many of these events are in each day.
Some are quiet significant!
```{r}
onecowrlm$df |> 
  mutate(
    is_LT_0.2 = corrected_intake_bybin <= 0.2
  ) |> 
  group_by(animal_id, date, is_LT_0.2) |> 
  summarise(
    n = n(),
    sum = sum(corrected_intake_bybin)
  )
```




```{r fig.width=12}

onecowdf <- bybin_test_df |>  filter(animal_id == 5183 ) #5183 5260

# onecowrlm <- onecowdf |>  dev_flag_and_replace_outliers()
onecowrlm <- onecowdf |>  dev_flag_and_replace_outliers(sd_thresh = Inf) 


p_test <- onecowrlm$df |> dev_plot_by_cow()
p_test
# plotly::ggplotly(p_test, width = 1000)
```

## try to add treshold lines
```{r fig.width=9}
p_test + 
  geom_function(fun = ~ 0.750/60 * .x)+
  geom_function(fun = ~ 0.1/60 * .x)+
  # coord_cartesian(ylim = c(0,1), xlim = c(0,500))+
  geom_rect(aes(xmin = 0, xmax = 60, ymin = 0, ymax = 0.2), fill = NA, colour = 'darkred')


```


```{r}
onecowrlm$df |> 
  ggplot(aes(x = start_time, y = instant_rate_of_intake_kg_min))+
  geom_point()
```



# check pred vs obs

```{r}
# onecowrlm$df |> glimpse()
# onecowrlm$df |> 
#   ggplot()+
#   geom_point(aes(x = corrected_intake_bybin, y = new_y))
# 
# onecowrlm$df |> 
#   mutate(
#     resid_intake = new_y - corrected_intake_bybin
#   ) |> 
#   ggplot()+
#   geom_point(aes(x = new_x, y = resid_intake))


daily_intakes <- 
  onecowrlm$df |> 
  group_by(animal_id, date) |> 
  summarise(
    daily_intake_bybin_clean = sum(corrected_intake_bybin),
    daily_intake_bycow_clean = sum(new_y),
    daily_intake_resid =  daily_intake_bycow_clean - daily_intake_bybin_clean
  ) 

daily_intakes |> 
  ggplot()+
  geom_point(
    aes(x = daily_intake_bybin_clean, y = daily_intake_bycow_clean)
  )


daily_intakes |> 
  ggplot()+
  geom_point(
    aes(x = date, y = daily_intake_resid)
  )

daily_intakes |> 
  ggplot() +
  geom_point(aes(x = date, y = daily_intake_bybin_clean), colour = 'blue')+
  geom_point(aes(x = date, y = daily_intake_bycow_clean), colour = 'red')
```


## Iterator for testing
```{r}

f_test_new <- function(animal_id_plot){
  onecowdf <- bybin_test_df |>  filter(animal_id == animal_id_plot) 
  
  onecowrlm <- onecowdf |>  dev_flag_and_replace_outliers(sd_thresh = 50)
  
  
  p_test <- onecowrlm$df |> dev_plot_by_cow()
  p_test + (p_test+ coord_cartesian(
    xlim = c(NA, 60*10),
    ylim = c(NA, 2)
  )) + patchwork::plot_layout(guides = 'collect')
  
}
```

```{r fig.width = 15, fig.height = 9}
animals_unique <- bybin_test_df$animal_id |> unique()
map(animals_unique, f_test_new)
```

# Model Residuals

Lookign at the residuals for this shows that the distribution of the residuals is highly skewed
```{r}
summary(onecowrlm$rlm)

onecow_residuals <- residuals(onecowrlm$rlm)


ggplot(data.frame(resid = onecow_residuals))+
  geom_histogram(aes(x = resid ), bins = 100)+
  scale_y_continuous(trans = 'log2')+
  geom_vline(xintercept = c(IQR(onecow_residuals), -IQR(onecow_residuals) * 3), colour = 'red')+
  geom_vline(xintercept = c( onecowrlm$rlm$s, - onecowrlm$rlm$s) * 5, colour = 'blue')
```
Check for the second cow which had a lot of outliers underneath the curve in original analysis:
It shows that it is skewed opposite, but also that there is an extremely large outlier
```{r}
bybin_test_df$animal_id |> unique()
secondcowdf <- bybin_test_df |>  filter(animal_id == 4957) 

secondcowrlm <- secondcowdf |>  dev_flag_and_replace_outliers()
secondcowrlm

secondcow_residuals <- residuals(secondcowrlm$rlm)


ggplot(data.frame(resid = secondcow_residuals))+
  geom_histogram(aes(x = resid ), bins = 1000)+
  scale_y_continuous(trans = 'log2')+
  # coord_cartesian(xlim = c(-20, NA))+
  geom_vline(xintercept = c(IQR(secondcow_residuals), -IQR(secondcow_residuals) * 3 ), colour = 'red')
```



```{r}
thresh <- 3 * IQR(onecow_residuals)
thresh
5 * onecowrlm$s
```

```{r}
3 * IQR(secondcow_residuals)

5 * onecowrlm$s
```

```{r}
# Assuming 'residuals' is your vector of residuals
Q1 <- quantile(onecow_residuals, 0.25)
Q3 <- quantile(onecow_residuals, 0.75)
IQR <- Q3 - Q1

lower_fence <- Q1 - 1.5 * IQR
upper_fence <- Q3 + 1.5 * IQR

#outliers <- which(residuals < lower_fence | residuals > upper_fence)

```





# New idea - rate of change
It may be possible to use instantaneous rate of change, ie the actual rate of intake for each individual point 
to determine if it is 'physiologically real' as a first filter. This could be a SD threshold or it could be
based on logic... A cow can only eat so fast, but also good to not exclude what is 'possible but unlikely'


```{r}

modified_df <- 
  bybin_test_df |>
  filter(animal_id == 4897) |> #5183 4957
  mutate(instant_rate_of_change_kg_s = corrected_intake_bybin / corrected_feed_duration_seconds,
         instant_rate_of_change_kg_min = instant_rate_of_change_kg_s * 60) |> 
  arrange(desc(instant_rate_of_change_kg_s)) |> 
  filter(instant_rate_of_change_kg_min >= 0)



p_rate_intake <- 
  modified_df  |> 
   ggplot(aes(x = corrected_feed_duration_seconds))+
   geom_point(aes( y = corrected_intake_bybin, colour = instant_rate_of_change_kg_min), alpha = 0.5)+
  scale_color_viridis_c()

p_rate_intake

plotly::ggplotly(p_rate_intake)
```



```{r}

# modified_df |> View()
mean_y = mean(modified_df$instant_rate_of_change_kg_min, na.rm=TRUE)
sd_y = sd(modified_df$instant_rate_of_change_kg_min, na.rm=TRUE)
  
modified_df |> 
  ggplot()+
  geom_histogram(aes(x = instant_rate_of_change_kg_min), bins = 1000)+
   scale_y_continuous(trans = 'log10')+
   coord_cartesian(xlim = c(0,NA))+
   geom_vline(xintercept = c(mean_y+sd_y*1, mean_y-sd_y*1))+
   coord_cartesian(xlim = c(0, 2))+
  NULL


```

```{r}
library(patchwork)

f_test_newmethod <- 
  function(animal_id_to_plot){
    modified_df <- 
      bybin_test_df |>  
      filter(animal_id == animal_id_to_plot) |> #5183 4957
      mutate(instant_rate_of_change_kg_s = corrected_intake_bybin / corrected_feed_duration_seconds,
             instant_rate_of_change_kg_min = instant_rate_of_change_kg_s * 60) |> 
      arrange(desc(instant_rate_of_change_kg_s)) |> 
      filter(instant_rate_of_change_kg_min >= 0) |> 
      mutate(
        manual_outlier = case_when(
         
          instant_rate_of_change_kg_min > 2 ~ '>2 kg/min',
          instant_rate_of_change_kg_min < 0.05 ~ '<0.05 kg/min',
          instant_rate_of_change_kg_min < 0.075 ~ '<0.075 kg/min',
           corrected_feed_duration_seconds > (60*60) ~ "long_duration",
          .default = NA_character_
        ),
        is_manual_outlier = !is.na(manual_outlier)
      )
      
    
    p_rate_intake <- 
      modified_df  |> 
      ggplot(aes(x = corrected_feed_duration_seconds))+
      geom_point(aes( y = corrected_intake_bybin, colour = manual_outlier, shape = is_manual_outlier), alpha = 0.5)+
      scale_color_viridis_d(na.value = 'grey')
    
    p_rate_intake
    
    
    # modified_df |> View()
    mean_y = mean(modified_df$instant_rate_of_change_kg_min, na.rm=TRUE)
    sd_y = sd(modified_df$instant_rate_of_change_kg_min, na.rm=TRUE)
    
    p_hist <- 
      modified_df |> 
      ggplot()+
      geom_histogram(aes(x = instant_rate_of_change_kg_min), bins = 1000)+
      scale_y_continuous(trans = 'log10')+
      coord_cartesian(xlim = c(0,NA))+
      geom_vline(xintercept = c(mean_y+sd_y*1, mean_y-sd_y*1))+
      #coord_cartesian(xlim = c(0, 2))+
      labs(title = animal_id_to_plot)+
      NULL
    
    return( p_rate_intake + p_hist )
  }


```

```{r}

animals_unique <- bybin_test_df$animal_id |> unique()
map(animals_unique, f_test_newmethod)
```

```{r}
bybin_test_df |>  group_by(animal_id) |> count(sort=TRUE)
p_meal_int <- 
  bybin_test_df |>  
  # group_by(animal_id) |> 
  filter(animal_id == 5305) |> #5183 4957
  arrange(start_time, .by_group = TRUE) |> 
  mutate(
    meal_interval = start_time - lag(end_time),
    meal_interval_sec = as.numeric(meal_interval)
  ) |> 
  ggplot()+
  geom_histogram(aes(x=meal_interval_sec), 
                   bins = 200,
                 # binwidth = log10(30)
                 )+
   scale_x_continuous(trans='log10')+
  scale_y_continuous(trans = 'sqrt')
  NULL
p_meal_int
plotly::ggplotly(p_meal_int)
```

# Finalise functions for adding to package

# Set up test functions for dev
## flag and replace outliers
```{r}

final_dev_flag_and_replace_outliers <-
  function(df_in,
           col_intake = corrected_intake_bybin,
           col_duration = corrected_feed_duration_seconds,
           col_cow_id = animal_id,
           col_bin_id = bin_id,
           col_start_time = start_time,
           col_date = date,
           max_duration_min = 60,
           min_kg_min = 0.05,
           max_kg_min = 1.5,
           zero_thresh = 0.3,
           sd_thresh = Inf){
    #
    col_y <- rlang::ensym(col_intake)
    col_x <- rlang::ensym(col_duration)

    c_y <- rlang::enquo(col_intake) %>% rlang::as_name()
    c_x <- rlang::enquo(col_duration) %>% rlang::as_name()

    c_cow_id <- rlang::enquo(col_cow_id) %>% rlang::as_name()
    c_bin_id <- rlang::enquo( col_bin_id ) %>% rlang::as_name()
    c_start_time <- rlang::enquo( col_start_time ) %>% rlang::as_name()
    c_date <- rlang::enquo( col_date ) %>% rlang::as_name()

    # drop NA values - rlm() won't work otherwise
    # There shouldn't be NA value, as errors from first step retained their original intake values
    df_in <-
      df_in %>%
      tidyr::drop_na({{ col_intake }},  {{ col_duration }})

    ############################################# #
    # Check data
    # 1. that only 1 cow of data is entered
    # 2. that more than 3 rows of data are included for regression
    ############################################# #

    n_cows <- df_in %>% dplyr::pull({{ col_cow_id }}) %>% dplyr::n_distinct()
    if(n_cows > 1){
      warning("More than 1 cow detected in df_in. This function requires 1 cow at a time, see f_iterate_cows().")
      return(NULL)
    }

    n_row <- df_in %>% nrow()
    if(n_row < 5){
      warning(paste0(
        "Less than 5 events for current cow. Aborting regression fit and keeping original intakes & durations. Cow number:\n",
        df_in %>% dplyr::pull({{ col_cow_id}}) %>% unique(),
        "\nNumber of rows:\n",
        n_row
        ))

      # copy original values to new columns that would be added below
      # keep only minimum amount of columns to allow data to be merged with 'fitted' df's
      out <- df_in %>%
        dplyr::mutate(
          new_x = {{ col_duration }},
          new_y = {{ col_intake }}
        ) %>%
        dplyr::select( tidyselect::all_of(
          #all_of returns an error if some are missing, but requires char vector, hence the enquo(), as_name() + bang-bang
          c(
            !!c_cow_id,
            !!c_bin_id,
            !!c_start_time,
            !!c_date,
            !!c_x,
            !!c_y,
            'new_x',
            'new_y'
          )
        )) %>%
        dplyr::mutate(
          is_outlier = FALSE,
          outlier_pos_neg = 'insufficient_rows_for_regression'
        )

      return(out)
    }


    ############################################# #
    # Fit robust linear model to detect outliers
    ############################################# #

    # Set negative intakes and long durations (> 60 min) as outliers prior to first regression
    # This helps to maintain a more robust linear model, as very negative intakes or very long durations will still
    # skew the rlm().
    # df_in <- df_in %>% 
    #   dplyr::mutate(
    #     initial_outlier_check = {{ col_intake }} < 0 | {{ col_duration }} < 120
    #   )
    
    df_in <- 
      df_in |> 
      dplyr::mutate(instant_rate_of_intake_kg_s = {{ col_intake }} / {{ col_duration }},
             instant_rate_of_intake_kg_min = instant_rate_of_intake_kg_s * 60) |> 
      dplyr::arrange(dplyr::desc(instant_rate_of_intake_kg_s)) |> 
      dplyr::filter(instant_rate_of_intake_kg_min >= 0) |> 
      dplyr::mutate(
        manual_outlier_classification = dplyr::case_when(
          # ignore <= 60 seconds and < 300 g
          {{ col_duration }} <= 60 &  {{ col_intake }} < zero_thresh ~ 'Not Outlier',
          
          
          instant_rate_of_intake_kg_min > max_kg_min ~ paste0(">", max_kg_min, "kg/min"),
          # instant_rate_of_intake_kg_min > 2 ~ '>2 kg/min',
          instant_rate_of_intake_kg_min < min_kg_min ~ paste0("<", min_kg_min, "kg/min"),
          # instant_rate_of_intake_kg_min < 0.075 ~ '<0.075 kg/min',
          # instant_rate_of_intake_kg_min < 0.1 ~ '<0.100 kg/min',
           {{ col_duration }} > (max_duration_min * 60) ~ paste0("Long Duration (>", max_duration_min, " min)"),
          
          .default = 'Not Outlier'
        ),
        is_manual_outlier = manual_outlier_classification != 'Not Outlier'
      )
    
    # split data into 2 dataframes based on initial flag. 
    # Data removed here is re-attached to df after rlm() step
    df_in_rlm <- df_in %>% dplyr::filter(!is_manual_outlier)
    
    df_in_initial_outliers <- df_in %>% dplyr::filter(is_manual_outlier)
    
    
    # # INTERCEPT FIXED THROUGH 0:
    rlm_out  <- MASS::rlm(
      rlang::inject(!!col_y ~ 0+!!col_x),
      data = df_in_rlm,
      psi = MASS::psi.huber,
      method = "M",
      init = 'lts',
      maxit = 5000)
    
    # rlm_out  <- MASS::rlm(
    #   rlang::inject(!!col_y ~ !!col_x),
    #   data = df_in_rlm,
    #   psi = MASS::psi.huber,
    #   method = "M",
    #   init = 'lts',
    #   maxit = 1000)
    
    # return(rlm_out)
    
    # value from model used as 'sd' for outlier detection
    scale_num <-  rlm_out$s

    resid_df_outliers <-
      broom::augment(rlm_out, newdata = stats::model.frame(rlm_out))  %>%
      dplyr::bind_cols(
        df_in_rlm %>%
          dplyr::select(
            #all_of returns an error if some are missing, but requires char vector, hence the enquo(), as_name() + bang-bang
            tidyselect::all_of(
            c(
              !!c_cow_id,
              !!c_bin_id,
              !!c_start_time,
              !!c_date,
              "manual_outlier_classification",
              "is_manual_outlier",
              "instant_rate_of_intake_kg_min"
            )
          )
          )
      )  %>%
      # Add initial outliers back in:
      dplyr::bind_rows(
        df_in_initial_outliers %>%
          dplyr::select(
            tidyselect::all_of(
            c(
              !!c_y,
              !!c_x,
              !!c_cow_id,
              !!c_bin_id,
              !!c_start_time,
              !!c_date,
              "manual_outlier_classification",
              "is_manual_outlier",
              "instant_rate_of_intake_kg_min"
            )
          )
          )) |>
      dtplyr::lazy_dt() %>%
      dplyr::mutate(
        is_outlier = abs(.data$.resid) >= sd_thresh * scale_num | {{ col_intake }} < 0 | .data$is_manual_outlier == TRUE
        
        ) %>%
      dplyr::as_tibble() # required to collect lazy_dt()


    ##############################################
    # Fit bisector linear model that is symmetrical
    ##############################################

    # This allows for bi-directional prediction of either x or y
    # similar to SMA but easier to implement

    # select only points that were not considered outliers above to fit bisector line to
    # this is only used for calculation, and all data is still returned at end
    df_no_outliers <- resid_df_outliers  %>% dplyr::filter(.data$is_outlier == FALSE)
    

    # These methods are faster than others for getting values required:
    # uses names that are similar to Isobe 1990 paper

    # mean of x and y
    means <- df_no_outliers %>%
      dplyr::select({{ col_x }}, {{ col_y }}) %>%
      base::colMeans(na.rm=TRUE)

    # sum of squares calculations:
    SS <- df_no_outliers  %>%
      dplyr::select({{ col_x }}, {{ col_y }}) %>%
      dplyr::mutate(
        s_xy = ({{ col_x }} - means[[col_x]] ) *({{ col_y }} - means[[col_y]]),
        s_xx = ({{ col_x }} - means[[col_x]])^2,
        s_yy = ({{ col_y }} - means[[col_y]])^2)

    # Total sum of squares
    TSS <- SS %>% base::colSums()

    # Calculate slope and intercept for bisector model from Isobe 1990:
    b_xy <- TSS[['s_xy']] / TSS[['s_xx']] # normal lm
    b_yx <- TSS[['s_yy']] / TSS[['s_xy']] # inverse - used by bis

    # slope:
    b_bis <-  (b_xy + b_yx)^-1*(b_xy * b_yx - 1 + sqrt((1+b_xy^2)*(1+b_yx^2)))

    # Intercept:
    #b0_bis = means[[col_y]] - b_bis * means[[col_x]]
    
    # Force intercept to 0 as this is biologically more relevent and prevents estimating negative intakes
    b0_bis = 0

    ####################################################
    # Fit model for outliers:
    ####################################################
    # functions to predict in either direction
    .f_pred_y <- function(x){
      y = b_bis * x  + b0_bis
      return(y)
    }

    .f_pred_x <- function(y){
      x = (y - b0_bis) / b_bis
      return(x)
    }


    predicted_and_corrected <-
      resid_df_outliers %>%
      dtplyr::lazy_dt() %>%
      dplyr::mutate(
        # calculate predicted values for plotting regression
        predicted_y_bisector = b_bis * {{ col_x }} + b0_bis,
        residual_y_bisector = {{ col_intake }} - .data$predicted_y_bisector,
        
        # classify if outlier should be corrected along x or y axis:
        outlier_pos_neg = dplyr::case_when(.data$is_outlier & {{ col_intake }} < 0 ~ "neg_intake",
                                           .data$is_outlier & {{ col_duration }} < 0  ~ "neg_duration",
                                           .data$is_outlier & .data$residual_y_bisector < 0 ~ "neg",
                                           .data$is_outlier & .data$residual_y_bisector > 0  ~ "pos"),

        # New x and y - with outliers given predicted values:
        new_y = dplyr::case_match(.data$outlier_pos_neg,
                                  'pos' ~ .f_pred_y({{ col_duration }}),
                                  'neg_intake' ~ 0, #set neg intakes to 0
                                  .default =  {{ col_intake }} ),

        new_x = dplyr::case_match(.data$outlier_pos_neg,
                                  'neg' ~ .f_pred_x({{ col_intake }}),
                                  'neg_duration' ~ .f_pred_x({{ col_intake }}),
                                  .default = {{ col_duration }}),
        # store b0 and b_bis in columns to access later for rate of intake
        intercept = b0_bis,
        slope = b_bis,
        
      ) %>%
      dplyr::as_tibble() |>  # required to collect lazy_dt() 
      dplyr::mutate(
        #add final classification of all outliers
        outlier_classification = dplyr::case_when(
          is_manual_outlier == FALSE & is_outlier == TRUE ~ 'Residual > SD threshold',
          is_manual_outlier == TRUE ~ manual_outlier_classification,
          is_outlier == FALSE ~ "Not Outlier",
          .default = NA_character_
        )
      )
    
    
    
    return(list(df = predicted_and_corrected, rlm =  rlm_out, df_no_outliers = df_no_outliers))
  }
```

## Plot
```{r}

final_dev_plot_by_cow <- function(df,
                            max_intake_rate_kg_min = 1.5,
                            min_intake_rate_kg_min = 0.05,
                            outlier_exemption_max_duration = 1,
                            outlier_exemption_max_intake = 0.3,
                            col_intake = .data$corrected_intake_bybin,
                            col_duration = .data$corrected_feed_duration_seconds,
                            col_cow_id = .data$cow_id,
                            pt_size = 3){

  df_outliers <- df %>%  dplyr::filter(.data$is_outlier)

  # used to prevent lines breaking when plotting .fitted
  df_noNA <- df |> dplyr::filter(!is.na(.data$.fitted))

  # for setting coord-cartesian
  max_intake <- df |> dplyr::pull({{ col_intake }}) |> max()
  max_duration <- df |> dplyr::pull({{ col_duration }}) |> max()

  
  df_rates_of_intake_bounds <-
    data.frame(x_duration = seq(0, max_duration, by = 10)) |>
    dplyr::mutate(
      upper_line = max_intake_rate_kg_min/60 * .data$x_duration,
      lower_line = min_intake_rate_kg_min/60 * .data$x_duration
    )

  p <- df %>%
    ggplot2::ggplot(aes(x = {{ col_duration }}, y = {{ col_intake }}, text = paste("cow_id:", {{ col_cow_id }})))+
    ggplot2::geom_point(aes(
      colour = .data$outlier_pos_neg,
      fill = .data$outlier_classification,
      text = paste("Rate of Intake kg/min: ", .data$instant_rate_of_intake_kg_min)
    ),
    size = pt_size,
    shape = 21
    )+
    # Using the pre-calculated values allows better compatability with plotly
    ggplot2::geom_line(aes(x = .data$x_duration, y = .data$upper_line, linetype = 'Boundary of max intake rate kg/min'),
              colour = 'black',
              linewidth = 0.8,
              inherit.aes = FALSE,
              data = df_rates_of_intake_bounds)+
    ggplot2::geom_line(aes(x = .data$x_duration, y = .data$lower_line, linetype = 'Boundary of min intake rate kg/min'),
              colour = 'black',
              linewidth = 0.8,
              inherit.aes = FALSE,
              data = df_rates_of_intake_bounds)+

    ggplot2::geom_line(aes(y = .data$.fitted,
                  linetype = '1) Robust Linear Regression'),
              # colour = 'blue',
              linewidth = 0.8,
              data = df_noNA)+
    ggplot2::geom_line(aes(y = .data$predicted_y_bisector, linetype = '2) Bisector Regression'),
              # colour = 'blue',
              linewidth = 0.8,
              data = df_noNA)+

  ggplot2::scale_linetype_manual(
    values = c('1) Robust Linear Regression' = 'dashed',
               '2) Bisector Regression' = 'solid',
               'Boundary of max intake rate kg/min' = 'dotted',
               'Boundary of min intake rate kg/min' = 'twodash'
    )) +

    # add points for outliers only:
    # geom_point(aes(x = .data$new_x, y = .data$new_y, colour = .data$outlier_pos_neg), size = pt_size,
    #            data = df_outliers)+
    ggplot2::geom_point(aes(
      x = .data$new_x, y = .data$new_y,
      colour = .data$outlier_pos_neg,
      fill = .data$outlier_classification,
      # shape = .data$is_outlier
    ),
    size = pt_size, shape = 21,
    data = df_outliers
    )
  
  if (nrow(df_outliers) > 0){
  p2 <- p + 
    # Draw line between points that changed (inherits x and y from ggplot call):
    ggplot2::geom_segment(aes(xend = .data$new_x, yend = .data$new_y, colour = .data$outlier_pos_neg),
                 alpha = 0.75,
                 linewidth = 0.8,
                 data = df_outliers,
                 arrow = grid::arrow(angle = 20, length = ggplot2::unit(0.4, 'cm')),
                 linejoin = 'mitre')
  } else {
    p2 <- p
  }
  
  p3 <- p2 + 
    ggplot2::geom_rect(
      aes(xmin = 0, 
          xmax = outlier_exemption_max_duration*60, 
          ymin = 0, 
          ymax = outlier_exemption_max_intake), 
      fill = NA, 
      colour = 'red')+
    
    # rename labels and format:
    ggplot2::labs(
      title = df %>% dplyr::pull({{ col_cow_id }}) %>% unique(),
      linetype = "Fitted Line Type")+

    # NA values are from outlier_pos_neg (if NA it means it wasn't an outlier)
    ggplot2::scale_colour_viridis_d("Outlier correction type", option = 'D',
                                    end = 0.8, na.value = "grey60")+
    ggplot2::scale_fill_viridis_d("Outlier Classification", option = 'H',
                                  end = 0.8, na.value = "grey60")+
    ggplot2::theme_classic(base_size = 18)+
    ggplot2::theme(axis.text = ggplot2::element_text(colour = 'black'))+
    ggplot2::coord_cartesian(ylim = c(NA,max_intake),
                    # xlim = c(0,500)
    )+
    NULL

  return(p3)

}
```

Check if workign with plotly:
```{r}
animals_unique <- bybin_test_df$animal_id |> unique()
onecowdf <- bybin_test_df |>  filter(animal_id == animals_unique[1]) 
  
onecowrlm <- onecowdf |>  final_dev_flag_and_replace_outliers(sd_thresh = 50)

p_test <- onecowrlm$df |> final_dev_plot_by_cow()

p_test
plotly::ggplotly(p_test)

```




## Iterator for testing
```{r}

final_test_new <- function(animal_id_plot, df = bybin_test_df){
  onecowdf <- df |>  filter(animal_id == animal_id_plot) 
  
  onecowrlm <- onecowdf |>  final_dev_flag_and_replace_outliers(sd_thresh = 50)
  
  
  p_test <- onecowrlm$df |> final_dev_plot_by_cow()
  p_test + (p_test+ coord_cartesian(
    xlim = c(NA, 60*10),
    ylim = c(NA, 2)
  )) + patchwork::plot_layout(guides = 'collect')
  
}
```

```{r fig.width = 15, fig.height = 9}
animals_unique <- bybin_test_df$animal_id |> unique()
map(animals_unique, final_test_new)
```

# test on demo data from app
```{r}

df_uploaded <- IntakeInspectR::demo_insentec_data

min_date <- df_uploaded$date %>% min()
max_date <- df_uploaded$date %>% max()

df_filtered <- 
  df_uploaded %>% 
        dplyr::filter(date >= lubridate::ymd(min_date) &  date <= lubridate::ymd("2022-01-07")) 

list_cleaned <-
        IntakeInspectR::f_by_bin_clean(
          df_filtered,
          zero_thresh = 0.3, 
          feedout_thresh = 10, 
          col_bin_ID = feed_bin_id,
          col_date = date,
          col_start_time = start_time,
          col_start_weight = start_weight,
          col_end_weight = end_weight,
          col_intake = intake,
          log = FALSE
          )



```

```{r}
final_test_new_demo <- function(animal_id_plot, df = bybin_test_df){
  onecowdf <- df |>  filter(cow_id == animal_id_plot) 
  
  onecowrlm <- onecowdf |>  
    final_dev_flag_and_replace_outliers(
      col_intake = corrected_intake_bybin,
      col_duration = corrected_feed_duration_seconds,
      col_cow_id = cow_id,
      col_bin_id = feed_bin_id,
      col_start_time = start_time,
      col_date = date,
      max_duration_min = 60,
      min_kg_min = 0.05,
      max_kg_min = 0.8,
      zero_thresh = 0.3,
      sd_thresh = 20)
  
  
  p_test <- onecowrlm$df |> 
    final_dev_plot_by_cow(
      max_intake_rate_kg_min = 0.8,
      min_intake_rate_kg_min = 0.05,
      col_intake = corrected_intake_bybin,
      col_duration = corrected_feed_duration_seconds,
      col_cow_id = cow_id,
      pt_size = 3
    )
  
  
  p_test + (p_test+ coord_cartesian(
    xlim = c(NA, 60*5),
    ylim = c(NA, 1)
  )) + patchwork::plot_layout(guides = 'collect')
  
}
```

```{r fig.width=10}


animals_unique <- list_cleaned$df_cleaned$cow_id |> unique()
names(animals_unique) <- animals_unique

test_plots <- map(animals_unique, final_test_new_demo, df = list_cleaned$df_cleaned)

test_plots
```



## test missing data in rows
Check missing points in robust lm line:
```{r}
onecowdf <- list_cleaned$df_cleaned |>  filter(cow_id == 2135) 
  

onecowrlm <- onecowdf |>  
    final_dev_flag_and_replace_outliers(
      col_intake = corrected_intake_bybin,
      col_duration = corrected_feed_duration_seconds,
      col_cow_id = cow_id,
      col_bin_id = feed_bin_id,
      col_start_time = start_time,
      col_date = date,
      max_duration_min = 60,
      min_kg_min = 0.05,
      max_kg_min = 0.8,
      zero_thresh = 0.3,
      sd_thresh = 20)
  
onecowrlm_df <- onecowrlm$df

p_test <- onecowrlm_df |> 
    final_dev_plot_by_cow(
      max_intake_rate_kg_min = 0.8,
      min_intake_rate_kg_min = 0.05,
      col_intake = corrected_intake_bybin,
      col_duration = corrected_feed_duration_seconds,
      col_cow_id = cow_id,
      pt_size = 3
    )


p_test
# plotly::ggplotly(p_test)
```
```{r}
onecowrlm_df |> 
  ggplot(aes(x = corrected_feed_duration_seconds, y = .fitted))+
  geom_point()+
  geom_line()
```

## test 'object x not found'
```{r}
onecowdf <- list_cleaned$df_cleaned |>  filter(cow_id == 2018) 
  

onecowrlm <- onecowdf |>  
    final_dev_flag_and_replace_outliers(
      col_intake = corrected_intake_bybin,
      col_duration = corrected_feed_duration_seconds,
      col_cow_id = cow_id,
      col_bin_id = feed_bin_id,
      col_start_time = start_time,
      col_date = date,
      max_duration_min = 60,
      min_kg_min = 0.05,
      max_kg_min = 0.8,
      zero_thresh = 0.3,
      sd_thresh = 20)
  
onecowrlm_df <- onecowrlm$df

p_test2 <- onecowrlm_df |> 
    final_dev_plot_by_cow(
      max_intake_rate_kg_min = 0.8,
      min_intake_rate_kg_min = 0.05,
      col_intake = corrected_intake_bybin,
      col_duration = corrected_feed_duration_seconds,
      col_cow_id = cow_id,
      pt_size = 3
    )+ ggplot2::coord_cartesian(ylim = c(0,10))


p_test2
plotly::ggplotly(p_test2 , 
                 dynamicTicks = TRUE
                 )  |>  plotly::layout(yaxis = list(autorange = FALSE)) 

#p_test2$coordinates$limits$y
```

Problem with zooming is because of dynamic ticks

```{r}

p_test_coord <- ggplot(mtcars, aes(x = hp, y = mpg)) +
  geom_point() +
  labs(title = "Scatter Plot of Horsepower vs Miles Per Gallon",
       x = "Horsepower",
       y = "Miles Per Gallon") + ggplot2::coord_cartesian(ylim = c(0,60), xlim = c(100,200))


p_plotly <- plotly::ggplotly(p_test_coord)

p_plotly


# Extract the x-axis range from ggplot
p_plotly$x$layout$yaxis$range

# This gets coords (if set manually with coord_cartesian)
yrange <- p_test_coord$coordinates$limits$y

# manually set
p_plotly |> 
  #plotly::layout(yaxis = list(range= c(0,40))) |> 
  plotly::layout(yaxis = list(range= yrange)) 
```

