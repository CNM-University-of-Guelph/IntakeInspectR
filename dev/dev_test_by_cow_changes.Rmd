---
title: "dev - changes to regression 'by cow'"
output: html_notebook
---

After running analysis on large data it seems that the first fit of the regression is not always robust against very large negatives or very long durations. So, it would seem more appropriate to flag them as outliers first so that the initial fit can get a more realistic 'scaling factor' which is used as SD.

```{r}

test_flag_and_replace_outliers <-
  function(df_in,
           col_intake,
           col_duration,
           col_cow_id,
           col_bin_id,
           col_start_time,
           col_date,
           sd_thresh = 5){
    #
    col_y <- rlang::ensym(col_intake)
    col_x <- rlang::ensym(col_duration)

    c_y <- rlang::enquo(col_intake) %>% rlang::as_name()
    c_x <- rlang::enquo(col_duration) %>% rlang::as_name()

    c_cow_id <- rlang::enquo(col_cow_id) %>% rlang::as_name()
    c_bin_id <- rlang::enquo( col_bin_id ) %>% rlang::as_name()
    c_start_time <- rlang::enquo( col_start_time ) %>% rlang::as_name()
    c_date <- rlang::enquo( col_date ) %>% rlang::as_name()

    # drop NA values - rlm() won't work otherwise
    # There shouldn't be NA value, as errors from first step retained their original intake values
    df_in <-
      df_in %>%
      tidyr::drop_na({{ col_intake }},  {{ col_duration }})

    ############################################# #
    # Check data
    # 1. that only 1 cow of data is entered
    # 2. that more than 3 rows of data are included for regression
    ############################################# #

    n_cows <- df_in %>% dplyr::pull({{ col_cow_id }}) %>% dplyr::n_distinct()
    if(n_cows > 1){
      warning("More than 1 cow detected in df_in. This function requires 1 cow at a time, see f_iterate_cows().")
      return(NULL)
    }

    n_row <- df_in %>% nrow()
    if(n_row < 5){
      warning(paste0(
        "Less than 5 events for current cow. Aborting regression fit and keeping original intakes & durations. Cow number:\n",
        df_in %>% dplyr::pull({{ col_cow_id}}) %>% unique(),
        "\nNumber of rows:\n",
        n_row
        ))

      # copy original values to new columns that would be added below
      # keep only minimum amount of columns to allow data to be merged with 'fitted' df's
      out <- df_in %>%
        dplyr::mutate(
          new_x = {{ col_duration }},
          new_y = {{ col_intake }}
        ) %>%
        dplyr::select( tidyselect::all_of(
          #all_of returns an error if some are missing, but requires char vector, hence the enquo(), as_name() + bang-bang
          c(
            !!c_cow_id,
            !!c_bin_id,
            !!c_start_time,
            !!c_date,
            !!c_x,
            !!c_y,
            'new_x',
            'new_y'
          )
        )) %>%
        dplyr::mutate(
          is_outlier = FALSE,
          outlier_pos_neg = 'insufficient_rows_for_regression'
        )

      return(out)
    }


    ############################################# #
    # Fit robust linear model to detect outliers
    ############################################# #

    # Set negative intakes and long durations (> 60 min) as outliers prior to first regression
    # This helps to maintain a more robust linear model, as very negative intakes or very long durations will still
    # skew the rlm().
    df_in <- df_in %>% 
      dplyr::mutate(
        initial_outlier_check = {{ col_intake }} < 0
      )
    
    # split data into 2 dataframes based on initial flag. 
    # Data removed here is re-attached to df after rlm() step
    df_in_rlm <- df_in %>% dplyr::filter(!initial_outlier_check)
    
    df_in_initial_outliers <- df_in %>% dplyr::filter(initial_outlier_check)
    
    
    # INTERCEPT FIXED THROUGH 0:
    rlm_out  <- MASS::rlm(
      rlang::inject(!!col_y ~ 0+!!col_x),
      data = df_in_rlm,
      psi = MASS::psi.huber,
      method = "MM",
      maxit = 250)

    # value from model used as 'sd' for outlier detection
    scale_num <-  rlm_out$s
    
    resid_df_outliers <-
      broom::augment(rlm_out, newdata = stats::model.frame(rlm_out))  %>%
      dplyr::bind_cols(
        df_in_rlm %>%
          dplyr::select(
            #all_of returns an error if some are missing, but requires char vector, hence the enquo(), as_name() + bang-bang
            tidyselect::all_of(
            c(
              !!c_cow_id,
              !!c_bin_id,
              !!c_start_time,
              !!c_date
            )
          )
          )
      )  %>%
      # Add initial outliers back in:
      dplyr::bind_rows(
        df_in_initial_outliers %>%
          dplyr::select(
            tidyselect::all_of(
            c(
              !!c_y,
              !!c_x,
              !!c_cow_id,
              !!c_bin_id,
              !!c_start_time,
              !!c_date
            )
          )
          )) |> 
      dtplyr::lazy_dt() %>%
      dplyr::mutate(
        is_outlier = abs(.data$.resid) >= sd_thresh * scale_num | {{ col_intake }} < 0,
        rate_g_min = ({{ col_intake }}*1000)/({{ col_duration }}/60),

        # classify if outlier should be corrected along x or y axis:
        outlier_pos_neg = dplyr::case_when(.data$is_outlier & {{ col_intake }} < 0 ~ "neg_intake",
                                           .data$is_outlier & {{ col_duration }} < 0  ~ "neg_duration",
                                           .data$is_outlier & .data$.resid < 0 ~ "neg",
                                           .data$is_outlier & .data$.resid > 0  ~ "pos")) %>%
      dplyr::as_tibble() # required to collect lazy_dt()


    ##############################################
    # Fit bisector linear model that is symmetrical
    ##############################################

    # This allows for bi-directional prediction of either x or y
    # similar to SMA but easier to implement

    # select only points that were not considered outliers above to fit bisector line to
    # this is only used for calculation, and all data is still returned at end
    df_no_outliers <- resid_df_outliers  %>% dplyr::filter(.data$is_outlier == FALSE)


    # These methods are faster than others for getting values required:
    # uses names that are similar to Isobe 1990 paper

    # mean of x and y
    means <- df_no_outliers %>%
      dplyr::select({{ col_x }}, {{ col_y }}) %>%
      base::colMeans(na.rm=TRUE)

    # sum of squares calculations:
    SS <- df_no_outliers  %>%
      dplyr::select({{ col_x }}, {{ col_y }}) %>%
      dplyr::mutate(
        s_xy = ({{ col_x }} - means[[col_x]] ) *({{ col_y }} - means[[col_y]]),
        s_xx = ({{ col_x }} - means[[col_x]])^2,
        s_yy = ({{ col_y }} - means[[col_y]])^2)

    # Total sum of squares
    TSS <- SS %>% base::colSums()

    # Calculate slope and intercept for bisector model from Isobe 1990:
    b_xy <- TSS[['s_xy']] / TSS[['s_xx']] # normal lm
    b_yx <- TSS[['s_yy']] / TSS[['s_xy']] # inverse - used by bis

    # slope:
    b_bis <-  (b_xy + b_yx)^-1*(b_xy * b_yx - 1 + sqrt((1+b_xy^2)*(1+b_yx^2)))

    # Intercept:
    b0_bis = means[[col_y]] - b_bis * means[[col_x]]


    ####################################################
    # Fit model for outliers:
    ####################################################
    # functions to predict in either direction
    .f_pred_y <- function(x){
      y = b_bis * x  + b0_bis
      return(y)
    }

    .f_pred_x <- function(y){
      x = (y - b0_bis) / b_bis
      return(x)
    }


    predicted_and_corrected <-
      resid_df_outliers %>%
      dtplyr::lazy_dt() %>%
      dplyr::mutate(
        # calculate predicted values for plotting regression
        predicted_y_bisector = b_bis * {{ col_x }} + b0_bis,

        # New x and y - with outliers given predicted values:
        new_y = dplyr::case_match(.data$outlier_pos_neg,
                                  'pos' ~ .f_pred_y({{ col_duration }}),
                                  'neg_intake' ~ 0, #set neg intakes to 0
                                  .default =  {{ col_intake }} ),

        new_x = dplyr::case_match(.data$outlier_pos_neg,
                                  'neg' ~ .f_pred_x({{ col_intake }}),
                                  'neg_duration' ~ .f_pred_x({{ col_intake }}),
                                  .default = {{ col_duration }}),
        # store b0 and b_bis in columns to access later for rate of intake
        intercept = b0_bis,
        slope = b_bis

      ) %>%
      dplyr::as_tibble() # required to collect lazy_dt()



    return(predicted_and_corrected)
  }


```


```{r}

test_plot_by_cow <- function(df,
                            col_intake,
                            col_duration,
                            pt_size = 3){

  df_outliers <- df %>%  dplyr::filter(!is.na(.data$outlier_pos_neg))

  df %>%
    ggplot(aes(x = {{ col_duration }}, y = {{ col_intake }}, text = paste("cow_id:", .data$cow_id)))+
    geom_point(aes(shape = .data$is_outlier, colour = .data$outlier_pos_neg), size = pt_size)+
    geom_line(aes(y = .fitted, linetype = '1) Robust Linear Regression'),
              colour = 'blue', linewidth = 1)+
    geom_line(aes(y = .data$predicted_y_bisector, linetype = '2) Bisector Regression'),
              colour = 'blue', linewidth = 1)+
    ggplot2::scale_linetype_manual(values = c('1) Robust Linear Regression' = 'dashed',
                                     '2) Bisector Regression' = 'solid')) +

    # add points for outliers only:
    geom_point(aes(x = .data$new_x, y = .data$new_y, colour = .data$outlier_pos_neg), size = pt_size,
               data = df_outliers)+

    # Draw line between points that changed (inherits x and y from ggplot call):
    geom_segment(aes(xend = .data$new_x, yend = .data$new_y, colour = .data$outlier_pos_neg),
                 alpha = 0.75,
                 linewidth = 0.8,
                 data = df_outliers,
                 arrow = grid::arrow(angle = 20, length = ggplot2::unit(0.6, 'cm')),
                 linejoin = 'mitre')+
    # rename labels and format:
    labs(title = paste(unique(df$cow_id)),
         linetype = "Fitted Line Type")+
    # NA values are from outlier_pos_neg (if NA it means it wasn't an outlier)
    ggplot2::scale_colour_viridis_d("Outlier type", option = 'D',
                                    end = 0.8, na.value = "grey60")+
    ggplot2::theme_classic(base_size = 18)+
    ggplot2::theme(axis.text = ggplot2::element_text(colour = 'black'))

}


```


# import testing data
```{r}
load("./data/demo_insentec_data.rda")
glimpse(demo_insentec_data)
```

```{r}
 demo_insentec_data |> count(cow_id, sort = TRUE)
```

```{r}
df_one_cow <- demo_insentec_data |> filter(cow_id == 2040)
```



```{r}

df_out <- test_flag_and_replace_outliers(
  df_one_cow,
  col_intake = intake,
  col_duration = feed_duration,
  col_cow_id = cow_id,
  col_bin_id = feed_bin_id,
  col_start_time = start_time,
  col_date = date,
  sd_thresh = 5)
```

```{r}
test_plot_by_cow(df_out, intake, feed_duration)
```

